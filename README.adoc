= Httprouter

image:https://img.shields.io/badge/vert.x-4.4.3-purple.svg[link="https://vertx.io"]

This application was generated using http://start.vertx.io

== Building

To launch your tests:
```
./mvnw clean test
```

To package your application:
```
./mvnw clean package
```

To run your application:
```
./mvnw clean compile exec:java
```

== Help

* https://vertx.io/docs/[Vert.x Documentation]
* https://stackoverflow.com/questions/tagged/vert.x?sort=newest&pageSize=15[Vert.x Stack Overflow]
* https://groups.google.com/forum/?fromgroups#!forum/vertx[Vert.x User Group]
* https://discord.gg/6ry7aqPWXy[Vert.x Discord]
* https://gitter.im/eclipse-vertx/vertx-users[Vert.x Gitter]





= Introdução:
No mundo do desenvolvimento de aplicações web modernas, ter um roteamento eficiente é essencial para construir APIs robustas e flexíveis. O toolkit Vert.x oferece um poderoso sistema de roteamento HTTP que permite definir e gerenciar facilmente as rotas da sua aplicação. Neste artigo, vamos explorar como utilizar o roteamento no Vert.x, juntamente com suas capacidades HTTP, para criar aplicações web.
Para uma introdução das capacidades do toolkit vamos abordar conceitos básicos, porém os mesmos conceitos são aplicados em aplicações completas e escaláveis.

O Vert.x oferece uma solução de roteamento flexível e fácil de usar por meio da classe Router.
Vamos começar com um exemplo de código que demonstra como configurar rotas básicas no Vert.x:

@Override
  public void start(Promise<Void> startPromise) throws Exception {

   Router router = Router.router(vertx);

// Rota para listagem de usuários
    router.route("/api/usuarios").handler(ctx -> {
      // Manipulação da requisição
      ctx.response().putHeader("Content-Type", "application/json")
       //sua lógica de negócio devolvendo uma listagem de usuários
        .end(getUsers().encode());
    });

// Rota para detalhes de um usuário específico
    router.route("/api/usuarios/:id").handler(ctx -> {
      String id = ctx.request().getParam("id");
      // Manipulação da requisição
      int statusCode = 200;
      String message = "OK";
      String body = "";
      try {
		
    	  body = findUser(Integer.parseInt(id)).encode();
	} catch (Exception e) {
		System.out.println(e);
		statusCode = 404;
		message = "Not found";
	} 
      ctx
          .response()
          .setStatusCode(statusCode)
          .setStatusMessage(message)
          .putHeader("Content-Type", "application/json")
        .end(body);
    });

// Criação do servidor HTTP e configuração do roteador
    vertx.createHttpServer()
      .requestHandler(router)
      .listen(8080 , http -> {
          if (http.succeeded()) {
              startPromise.complete();
              System.out.println("Servidor HTTP Iniciado 8080");
            } else {
              startPromise.fail(http.cause());
            }
          });
  }

 
Nesse exemplo, criamos uma instância da classe Router para lidar com o roteamento das requisições HTTP. Em seguida, definimos duas rotas básicas. A rota /api/usuarios é responsável por lidar com requisições para listar usuários, enquanto a rota /api/usuarios/:id é usada para obter os detalhes de um usuário específico.

Dentro dos manipuladores de rota, podemos acessar informações da requisição, como parâmetros e cabeçalhos, utilizando o objeto ctx. No exemplo, obtemos o parâmetro id da requisição para a rota de detalhes do usuário.

Em seguida, configuramos o cabeçalho Content-Type como application/json e enviamos a resposta adequada de acordo com a rota. Por fim, criamos um servidor HTTP utilizando vertx.createHttpServer(), configuramos o roteador como manipulador de requisições com requestHandler(router) e o escutamos na porta 8080 com o método listen.

Agora, vamos criar uma classe de teste para demonstrar como utilizar o roteamento e realizar chamadas às rotas configuradas:

@ExtendWith(VertxExtension.class)
public class MainVerticleTest {

    private Vertx vertx;
    private int port;

    @BeforeEach
    void setUp(Vertx vertx, VertxTestContext testContext) {
        this.vertx = vertx;

        // implanta the MainVerticle
        vertx.deployVerticle(MainVerticle.class.getName(), testContext.succeeding(id -> testContext.completeNow()));

        // Porta do server.
        port = 8080;
    }

    @AfterEach
    void tearDown(VertxTestContext testContext) {
        vertx.close(testContext.succeeding(id -> testContext.completeNow()));
    }

    @Test
    void testHelloVertxEndpoint(VertxTestContext testContext) {
        // Create an HTTP client
        HttpClient client = vertx.createHttpClient();

        // Send a GET request to the Hello Vert.x endpoint
        client.request(HttpMethod.GET, port, "localhost", "/api/usuarios")
                .compose(req -> req.send().compose(HttpClientResponse::body))
                .onSuccess(body -> {
                	System.out.println(body);
                    // Assert the response
                    testContext.verify(() -> {
                    	assertEquals("{\"status\":\"200\",\"message\":\"Listagem de usuários\",\"users\":[{\"name\":\"John Doe\",\"age\":30},{\"name\":\"Jane Smith\",\"age\":35}]}",
                    			body.toString());
                    });

                    testContext.completeNow();
                })
                .onFailure(testContext::failNow);
                
    }
    
 
 
Nessa classe de teste, criamos uma instância do Vert.x e um cliente HTTP utilizando vertx.createHttpClient(). Em seguida, fazemos chamadas HTTP para as rotas configuradas no exemplo anterior.
Ao fazer uma chamada para a rota /api/usuarios, capturamos a resposta e imprimimos o corpo da resposta no console. Da mesma forma, fazemos uma chamada para a rota /api/usuarios/1 e também imprimimos o corpo da resposta.

Conclusão:
O Vert.x oferece um poderoso sistema de roteamento HTTP, permitindo que você construa APIs flexíveis e de alto desempenho. Combinado com as capacidades de manipulação de requisições e respostas HTTP, assim como suporte a outras tecnologias como WebSockets e demais, o Vert.x oferece uma solução completa para o desenvolvimento de aplicações web escaláveis e interativas.

Espero que este artigo tenha fornecido uma visão básica das capacidades de roteamento no Vert.x e como elas se integram com as funcionalidades HTTP. 
O Código completo está no github: 
Fonte:
    https://vertx.io/
